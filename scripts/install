#!/bin/bash
info()  {
    in_box
    echo "[INFO] $@"
}
debug() {
    in_box
    if [ "$DEBUG" -eq 1 ]; then
        printf "${COLOR_PURPLE}[DEBUG] $@ ${COLOR_RESET}\n"
    fi
}
error() {
    in_box
    printf "${COLOR_RED}[ERROR] $@ ${COLOR_RESET}\n" >&2
}

prompt_user() {
    local prompt="$1"
    local default="$2"
    shift 2  # Remove the first two arguments

    if [ $# -gt 0 ]; then
        # Display options if more than two arguments are passed
        echo "$prompt (choose an option, default: $default):"
        local i=1
        for option in "$@"; do
            echo "  [$i] $option"
        done

        # Read user input
        read -p "Enter choice: " choice

        # Validate numeric choice
        if [[ "$choice" == "" ]]; then
            echo "$default"
        elif [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le $# ]; then
            echo "${!choice}"
        else
            echo "You typed an invalid option ($choice). Try again."
            prompt_user "$prompt" "$default" "$@"
        fi
    else
        # Standard input prompt
        read -p "$prompt (default: $default): " input
        echo "${input:-$default}"
    fi
}


# =====================================
COLUMNS=$(tput cols)  # Use tput for portability
BOX_WIDTH=$((COLUMNS - 4))
BOX_WIDTH_TEXT=$((BOX_WIDTH - 2))

# Global variables to manage the box state
# declare -i 
box_open=0
position=0
# declare -a box_content # ANSI escape codes for basic styling (optional, but improves readability)
declare -r COLOR_GREEN='\033[0;32m'
declare -r COLOR_YELLOW='\033[0;33m'
declare -r COLOR_PURPLE='\033[0;35m'
declare -r COLOR_BLUE='\033[0;34m'
declare -r COLOR_RESET='\033[0m'
declare -r COLOR_RED='\033[0;31m'

# =====================================
# Function to draw into the box
in_box() {
    if [ "$#" -eq 0 ]; then
        if [ "$box_open" -eq 1 ]; then  # close box
            # Close the box
            if [ $position -gt 0 ]; then
                spaces_in_line=$(( BOX_WIDTH_TEXT - position))
                printf "%-${spaces_in_line}s â”‚\n" " "
            fi
            printf "${COLOR_BLUE}â””%${BOX_WIDTH}sâ”˜\n" "" | tr ' ' 'â”€'
            printf "${COLOR_RESET}" # Reset colors
            box_open=0
        fi
        return
    fi

    if [ "$box_open" -eq 0 ]; then
        # Open the box
        box_open=1
        position=0
        printf "${COLOR_BLUE}â”Œ%${BOX_WIDTH}sâ”\n" "" | tr ' ' 'â”€'
    fi
    
    if [ "$#" -gt 0 ]; then
        local left_to_show="$*"
        while [[ -n "$left_to_show" ]]; do
        
            if [ $position -eq 0 ]; then
                printf "${COLOR_BLUE}â”‚ "
            fi
            spaces_in_line=$((BOX_WIDTH_TEXT - position))
            chunk="${left_to_show:0:spaces_in_line}"
            
            if [[ "$chunk" == *$'\n'* ]]; then
                # echo "Chunk $chunk of $left_to_show"
                # Process the part before the newline
                chunk="${chunk%%$'\n'*}"
                printf "%-${spaces_in_line}s â”‚\n" "$chunk"
                chunk_size=$(( 1 + ${#chunk}))
                left_to_show="${left_to_show:chunk_size}"
                position=0
                continue
            fi
            chunk_size=${#chunk}
            printf "%s" "$chunk"
            position=$(( (position + chunk_size) % BOX_WIDTH_TEXT ))
            left_to_show="${left_to_show:chunk_size}"

            if [ $position -eq 0 ]; then
                printf " â”‚\n"
            fi
        done
    
        # # Collect the text into a single string.
        # local var="$*"  
        # local carry=""
        # local buffer=""

        # # Iterate through the string and handle wrapping manually
        # while [[ -n "$var" ]]; do
        #     # If there's a newline in the string, split it
        #     if [[ "$var" == *$'\n'* ]]; then
        #         # Process the part before the newline
        #         chunk="${var%%$'\n'*}"
        #         var="${var#*$'\n'}"
        #         printf "${COLOR_BLUE}â”‚ %-${BOX_WIDTH_TEXT}s â”‚\n" "$chunk"
        #     else
        #         # Process normally when no newline is present
        #         chunk="${var:0:$BOX_WIDTH_TEXT}"
        #         var="${var:$BOX_WIDTH_TEXT}"

        #         # If there is still remaining text, store it in the buffer
        #         if [[ ${#chunk} -lt $BOX_WIDTH_TEXT && -n "$var" ]]; then
        #             carry="$var"
        #             var=""
        #             buffer="$carry"
        #         fi
        #         printf "${COLOR_BLUE}â”‚ %-${BOX_WIDTH_TEXT}s â”‚\n" "$chunk"
        #     fi
        # done
    fi
}
# =================================

PROGRESS_ANIM="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
SPINNER_ON=0
# Start the spinner in the background
spin() {
	echo -ne " Thinking..."
    while :; do
        for (( i=0; i<${#PROGRESS_ANIM}; i++ )); do
            sleep 0.1
            # Print a carriage return (\r) and then the spinner character
            echo -ne "\r${PROGRESS_ANIM:$i:1}"
        done
    done
}
spinner() {
    if [ "$SPINNER_ON" -eq 0 ]; then
        SPINNER_ON=1
        spin &
        spinner_pid=$!
    else
        SPINNER_ON=0
        kill $spinner_pid
        wait $spinner_pid 2>/dev/null
        echo -ne "\r "
        echo -ne "\r"
    fi
}
# =================================

# KEY="mysecretpassword"  # Change this to a strong password
# IV="1234567890abcdef"   # Change this to a 16-byte IV

encode_encrypt() {
    local plaintext="$1"
    local do_encrypt="$2"
    local curr_value
    #encode
    curr_value=$(echo -n "$plaintext" | base64)
    #encrypt
    if [ "$do_encrypt" -eq 1 ]; then
        curr_value=$(echo -n "$encoded" | openssl enc -aes-256-cbc -e -base64 -K "$(echo -n "$KEY" | xxd -p)" -iv "$(echo -n "$IV" | xxd -p)")
    fi
    echo "$curr_value"
}

decrypt_decode() {
    local encrypted="$1"
    local do_decrypt="$2"
    local curr_value
    #decrypt
    if [ "$do_decrypt" -eq 1 ]; then
        curr_value=$(echo -n "$encrypted" | openssl enc -aes-256-cbc -d -base64 -K "$(echo -n "$KEY" | xxd -p)" -iv "$(echo -n "$IV" | xxd -p)")
    fi
    #decode
    curr_value=$(echo -n "$curr_value" | base64 --decode)

    echo "$curr_value"
}

# # Example Usage
# original="Hello, World!"
# encrypted=$(encode_encrypt "$original")
# echo "Encrypted: $encrypted"

# decrypted=$(decrypt_decode "$encrypted")
# echo "Decrypted: $decrypted"
VERSION="v1.0.14"
REPO="doryashar/terminal-assistant"
DEBUG=${AI_DEBUG:-0}
EXEC_NAME="ai"
INSTALL_DIR="$HOME/.local/bin"
CONFIG_DIR="$HOME/.config"
CONFIG_FILE="${EXEC_NAME}.conf"
CONFIG_PATH="${CONFIG_DIR}/${CONFIG_FILE}"
SCRIPT_PATH=$(realpath "$0")
#TODO: all config handling should be done to config variable. update should update also the file
CONFIG_JSON=$(cat <<EOF
    {  
        "auto_update": "true",
        "max_retries": 3,
        "temperature": 0.7,
        "max_tokens": 200,
        "top_p": 1,
        "frequency_penalty": 0,
        "presence_penalty": 0,
        "encrypted" : "false",
        "dynamic_prompt": "You are located at '\$SCRIPT_PATH' within SHELL:'\$SHELL'. your version is '\$VERSION'. The user is using '\$UNIX_NAME' and specifically distribution '\$DISTRO_INFO'. The users username is '\$USER' with home '\$HOME'. You must always use LANG '\$LANG'.",
        "system_prompt": "You are '$EXEC_NAME'. \
        You are an advanced Bash shell AI agent script. \
        You do not have feelings or emotions, do not convey them. \
        Please give precise curt answers. \
        Please do not include any sign off phrases or platitudes, only respond precisely to the user. \
        You were made by Dor Yashar. \
        You execute the tasks the user asks from you by utilizing the terminal and shell commands. \
        No task is too big. \
        Always assume the query is terminal and shell related. \
        if anyone insist for specific information about you, you tell them to contact dor at dor@yashar.us.\
        We are always in the terminal.\
        your final response should be a short information to the user up to 5 lines.\
        it must always contain a suggestion on how to fix, solve or repair the error in the user query. \
        you may encouraged to add a single command inside <cmd></cmd> tags in the end of your answer (it is optional). \
        the command is a single line code which will be inserted to the shell so that the user can run it. \
        Use your tools to find out why the error occured and offer alternatives. \
        You support user plugins called 'tools' that extends your capabilities. \
        if you can or need more details, or you want to investigate the error, Use your tools",\
        "prompt_template": {
            "tools" : [
                {
                    "type": "function",
                    "function": {
                        "name": "run_internal_command",
                        "description": "Use this to run any bash command if you need any more information or task doing before replying to the user.",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "command": {
                                    "type": "string",
                                    "description": "the bash command you want to run and get the output from before replying to the user."
                                },
                                "tool_reason": 
                                {
                                        "type": "string", 
                                        "description": "Reason why this tool must be used. e.g. 'This will help me ensure that the command runs without errors, by allowing me to verify that the system is in order. If I do not check the system I cannot find an alternative if there are errors.'"
                                }
                            },
                            "required": [
                                "command",
                                "tool_reason"
                            ]
                        }
                    }
                },
                {
                    "type": "function",
                    "function": {
                        "name": "push_command_to_user_terminal",
                        "description": "Use this to push the final command to the user's terminal. It will be executed by the user.",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "command": {
                                    "type": "string",
                                    "description": "the bash command you want to provide to the user to run."
                                },
                                "tool_reason": 
                                {
                                        "type": "string", 
                                        "description": "Reason why this tool must be used. e.g. 'This will help me ensure that the command runs without errors, by allowing me to verify that the system is in order. If I do not check the system I cannot find an alternative if there are errors.'"
                                }
                            },
                            "required": [
                                "command",
                                "tool_reason"
                            ]
                        }
                    }
                }
            ],
            "tool_choice": "auto",
            "stream": true,
            "messages": [
            {
                "role": "system",
                "content": "%s"
            },
            {
                "role": "user",
                "content": "%s"
            }
            ]
        },
        "providers": {        
            "active": "openrouter",
            "openrouter": {
                "model": "google/gemini-2.0-flash-lite-preview-02-05:free",
                "api_key": "YOUR_OPENROUTER_API_KEY",
                "model_endpoint": "https://openrouter.ai/api/v1/chat/completions"
            }
        },
        "conversations": {
            "file": "$CONFIG_DIR/conversations.json"
        }
    }
EOF
)

# Determine the user's environment
UNIX_NAME=$(uname -srp)
# Attempt to fetch distro info from lsb_release or /etc/os-release
if [ -x "$(command -v lsb_release)" ]; then
	DISTRO_INFO=$(lsb_release -ds | sed 's/^"//;s/"$//')
elif [ -f "/etc/os-release" ]; then
	DISTRO_INFO=$(grep -oP '(?<=^PRETTY_NAME=").+(?="$)' /etc/os-release)
fi
# If we failed to fetch distro info, we'll mark it as unknown
if [ ${#DISTRO_INFO} -le 1 ]; then
	DISTRO_INFO="Unknown"
fi

create_config() {
    # if config dir not exists, create it
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
        if [ $? -ne 0 ]; then
            error "Failed to create config directory: $CONFIG_DIR"
            exit 1
        fi
    fi

    # Create the config file
    echo "$CONFIG_JSON" > "$CONFIG_PATH"
    # if failed, exit
    if [ $? -ne 0 ]; then
        error "Failed to create config file: $CONFIG_PATH"
        exit 1
    fi

    info "Created config: $CONFIG_PATH"
}

load_config() {
    if [ ! -f "$CONFIG_PATH" ]; then
        info "Config file not found. Creating a new one."
        create_config
    fi
    
    # Check if the file is valid JSON
    if ! jq empty "$CONFIG_PATH" >/dev/null 2>&1; then
        error "Invalid JSON format in $CONFIG_PATH!, please fix or remove this file."
        exit 1
    fi

    debug "Loading config: $CONFIG_PATH"
    CONFIG_JSON=$(jq ". * $(cat "$CONFIG_PATH")" <<< "$CONFIG_JSON") || exit 1
    # CONFIG_JSON=$(jq --argfile file "$CONFIG_PATH" '. * $file' <<< "$CONFIG_JSON")
    echo $CONFIG_JSON | jq . >/dev/null || exit 1

    # Override with config_override:
    tempfile=$(mktemp)
    config_override='{}'
    config_json=$(jq . "$CONFIG_PATH" | jq --argjson new "$config_override" '. * $new')
    echo "$config_json" > "$tempfile" && mv "$tempfile" "$CONFIG_PATH"

    debug "Loaded config: $CONFIG_PATH"
}

get_config_from_json_string() {
    # Example Usage:
    # REPO_NAME=$(get_config_value "repo")
    KEY="$1"
    JSON_STRING="$2"
    # return $(jq -r '.update_check_interval' "$CONFIG_FILE")

    # If the KEY is legal enviroment variable name and is set, use that:
    if [[ "$KEY" != *.* ]] && [[ -n "${!KEY}" ]]; then
        echo "${!KEY}"
        return
    fi

    # if key does not starts with a dot, add it
    if [[ "$KEY" != .* ]]; then
        KEY=".$KEY"
    fi

    # Read value from JSON file
    # local VALUE=$(jq -r --arg key "$KEY" '.[$key] // empty' "$JSON_STRING")
    local VALUE=$(echo "$JSON_STRING" | jq -r "$KEY // empty")

    # Check if value is empty
    if [ -z "$VALUE" ]; then
        error "Key '$KEY' not found in $JSON_STRING" >&2
        return 2
    fi

    echo "$VALUE"
}

get_config() {
    get_config_from_json_string "$1" "$CONFIG_JSON" #"$(cat $CONFIG_PATH)"
    return $?
}

update_json_string() {
    echo TODO
}
update_json_file() {
    local KEY="$1"
    local VALUE="$2"
    local FILE_PATH="$3"

    tmpfile=$(mktemp)
    # Modify JSON file and overwrite it
    # jq --arg key "$KEY" --arg value "$VALUE" '.[$key] = $value' "$FILE_PATH" > "${tmpfile}" && mv "${tmpfile}" "$FILE_PATH"
    # jq --argjson value "\"$VALUE\"" "$KEY = $value" "$FILE_PATH" > "${tmpfile}" && mv "${tmpfile}" "$FILE_PATH"

    # Detect if VALUE is a number or a boolean
    if [[ "$VALUE" =~ ^[0-9]+$ ]] || [[ "$VALUE" =~ ^true|false$ ]]; then
        jq "$KEY = $VALUE" "$FILE_PATH" > "$tmpfile" && mv "$tmpfile" "$FILE_PATH"
    else
        jq --arg value "$VALUE" "$KEY = \$value" "$FILE_PATH" > "$tmpfile" && mv "$tmpfile" "$FILE_PATH"
    fi
    
    # Check if the update was successful
    if [ $? -ne 0 ]; then
        error "Failed to update $KEY in $FILE_PATH"
        return 1
    fi
    debug "Updated $KEY to $VALUE in $FILE_PATH"

}
update_config() {
    local KEY=".$1"
    local VALUE="$2"
    local FILE_PATH="$CONFIG_PATH"
    update_json_file "$KEY" "$VALUE" "$FILE_PATH"
    return $?
}

remove_config() {
    local KEY=".$1"

    # Temporary file for the modified JSON
    local tmpfile=$(mktemp)

    # Remove the key from the JSON file using jq
    jq "del($KEY)" "$CONFIG_PATH" > "$tmpfile"

    # Check if the operation was successful
    if [ $? -ne 0 ]; then
        error "Failed to remove $KEY from $CONFIG_PATH"
        rm -f "$tmpfile"
        return 1
    fi

    # Replace the original config file with the modified one
    mv "$tmpfile" "$CONFIG_PATH"

    debug "Removed $KEY from $CONFIG_PATH"
    return 0
}

#!/bin/bash
# Save terminal content to a file
TUID=${PPID} # Parent PID (the terminal's parent process)
DATE_ID=$(date '+%Y-%m-%d_%H-%M-%S')
CAPTURE_HISTORY_LENGTH=10

# If you want history, you need to alias this script as: 
# { read input; echo "\n10 recent commands (history): $(history | tail -n 10 | head -n -1)\n$input"; } | $script_path
# this will not work:
# COMMAND_HISTORY_LENGTH=3
# HISTORY_COMMANDS=$(history | tail -n ${COMMAND_HISTORY_LENGTH} | head -n -1)
# echo "Command history (last $COMMAND_HISTORY_LENGTH lines): $HISTORY_COMMANDS"

# Function to stop the terminal session recording
stop_recording() {
    # Find the script process for the specific terminal session
    # if the variable doesnt exist, set it to the filename
    TERMINAL_CONTENT_FILENAME=${TERMINAL_CONTENT_FILENAME:-/tmp/terminal_output_${TUID}.txt}
    SCRIPT_PID=$(pgrep -f "script -q -f ${TERMINAL_CONTENT_FILENAME}")
    # SCRIPT_PID_=$(pgrep -f "$(basename "$0")")

    if [ -n "$SCRIPT_PID" ]; then
        PARENT_SCRIPT_PID=$(ps -o ppid= -p $SCRIPT_PID)
        debug "Script PID for $0: $SCRIPT_PID, Parent PID: $PARENT_SCRIPT_PID"
        # Kill the specific script process
        rm -f "${TERMINAL_CONTENT_FILENAME}" &
        kill "$SCRIPT_PID"
        debug "Background terminal recording process for session $TUID has been terminated."
    else
        debug "No background script process found for this terminal session."
    fi

    debug "Terminal recording stopped."
    return 0
}
start_recording() {
        export TERMINAL_CONTENT_FILENAME="/tmp/terminal_output_${TUID}.txt"
        debug "Terminal recording started in $TERMINAL_CONTENT_FILENAME."
        script -q -f "$TERMINAL_CONTENT_FILENAME" ; 
        debug "Done recording."
        
        # if the script isnt sourced, kill the parent shell
        if [ ! "$$" = "$PPID" ] && [ -z "$ASK_SOFT_KILL" ]; then
            debug "Script is executed normally - killing parent shell"
            kill -9 $(ps -o ppid= -p $$)
        # else
        #     echo "Script is sourced"
        fi
}
get_terminal_buffer() {
    # If the the variable exists and file exists, grab the history from the file otherwise start a new recording
    if [ -n "$TERMINAL_CONTENT_FILENAME" ]; then
        if [ -f "$TERMINAL_CONTENT_FILENAME" ]; then
            HISTORY=$(tail -n ${CAPTURE_HISTORY_LENGTH} ${TERMINAL_CONTENT_FILENAME} | head -n -1)
            echo "$HISTORY"
            return 0
        else
            # If the history file is missing, find and kill the background `script` process for the terminal
            stop_recording;
            # start_recording
        fi
    else 
        # If the variable doesn't exist, start a new recording
        # start_recording
        echo "ERR"
    fi
    return 1
}
# # Use `tput` to grab the terminal's screen buffer and save to file
# tput smcup  # Save the current screen buffer
# tput rmcup  # Restore the saved buffer

# # Save the current content of the terminal (screen buffer) to the file
# cat /dev/tty > "$FILENAME"

# echo "Terminal content saved to $FILENAME"

#!/bin/bash
# (sleep 3; echo -n "ls -la HELLO" > /dev/tty) 
# (sleep 1; echo -n "ls -la HELLO" > /dev/pts/0) &
# (sleep 0.1 ; ./xtool type 'h' && ./xtool type 'e' )&
# ( sleep 1; printf "%s" "hihi" ) > /proc/$$/fd/0 
xdotool_exists=$(command -v xdotool)
if [ -n "$xdotool_exists" ]; then
    xtool="xdotool"
else
    xtool="./xtool"
fi

push_to_stdin() {
    TEXT="$*"
    # if xdotool exists, use it, otherwise use xtool
    
    # Loop through each character in the string
    for ((i = 0; i < ${#TEXT}; i++)); do
        CHAR="${TEXT:$i:1}"  # Extract single character

        # Send each character using xtool (replace `xtool key` with the correct syntax)
        $xtool type "$CHAR"

        # Optional: Add a small delay for a more natural typing effect
        sleep 0.02
    done
}
init_conversations() {
    CONVERSATIONS_FILE=$(get_config conversations.file)
    if [ ! -f "$CONVERSATIONS_FILE" ]; then
        echo '{"conversations": {}}' > "$CONVERSATIONS_FILE"
    fi
    jq . "$CONVERSATIONS_FILE" > /dev/null || {
        error "Invalid JSON in $CONVERSATIONS_FILE"
        exit 1
    }
    debug "Conversations file: $CONVERSATIONS_FILE"
}

generate_conversation_id() {
    echo "conv_$(date +%s)_$(openssl rand -hex 4)"
}

create_new_conversation() {
    local model="$1"
    local system_prompt="$2"
    local conv_id=$(generate_conversation_id)
    
    local tmpfile=$(mktemp)
    
    # if conversations file does not exist, create it:
    init_conversations

    jq --arg id "$conv_id" \
       --arg model "$model" \
       --arg system "$system_prompt" \
       --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
       '.conversations[$id] = {
           "metadata": {
               "created_at": $timestamp,
               "model": $model,
               "system_prompt": $system
           },
           "messages": []
       }' "$CONVERSATIONS_FILE" > "$tmpfile" && mv "$tmpfile" "$CONVERSATIONS_FILE"
    
    echo "$conv_id"
}

save_message() {
    local conv_id="$1"
    local role="$2"
    local content="$3"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    local tmpfile=$(mktemp)
    
    jq --arg id "$conv_id" \
       --arg role "$role" \
       --arg content "$content" \
       --arg timestamp "$timestamp" \
       '.conversations[$id].messages += [{
           "timestamp": $timestamp,
           "role": $role,
           "content": $content
       }]' "$CONVERSATIONS_FILE" > "$tmpfile" && mv "$tmpfile" "$CONVERSATIONS_FILE"
}

get_conversation_history() {
    local conv_id="$1"
    local count=${2:-10}
    
    if [ -z "$conv_id" ]; then
        # List all conversations with their metadata
        jq -r '.conversations | to_entries[] | "\(.key): \(.value.metadata.model) (\(.value.metadata.created_at))"' "$CONVERSATIONS_FILE"
    else
        # Show specific conversation details
        jq -r --arg id "$conv_id" '
            .conversations[$id] | 
            "Conversation: \($id)\n" +
            "Model: \(.metadata.model)\n" +
            "System Prompt: \(.metadata.system_prompt)\n" +
            "Created: \(.metadata.created_at)\n" +
            "\nMessages:\n" +
            (.messages[-($count|tonumber):] | .[] | "[\(.timestamp)] \(.role): \(.content)")
        ' "$CONVERSATIONS_FILE"
    fi
}
handle_http_code() {
    # echo "HTTP $http_code Retry: $retry_count, Max Retries: $max_retries"
    case $http_code in
            200)
                debug "HTTP 200 OK"
                return 0
                ;;
            401|145)
                save_message "$conv_id" "system" "Error ($http_code): Invalid API key"
                error "Authentication failed ($http_code). Please check your API key."
                return 1
                ;;
            429)
                if [ $retry_count -lt $((max_retries-1)) ]; then
                    save_message "$conv_id" "system" "Rate limit exceeded, retrying..."
                    error "Rate limit exceeded, retrying..."
                    sleep $((2 ** retry_count))
                    ((retry_count++))
                    return 2
                else
                    save_message "$conv_id" "system" "Error: Rate limit exceeded"
                    error "Rate limit exceeded after $max_retries retries"
                    return 1
                fi
                ;;
            500|502|503|504)
                if [ $retry_count -lt $((max_retries-1)) ]; then
                    save_message "$conv_id" "system" "Server error ($http_code), retrying..."
                    error "Server error ($http_code), retrying..."
                    sleep $((2 ** retry_count))
                    ((retry_count++))
                    return 2
                else
                    save_message "$conv_id" "system" "Error: Server error after multiple retries"
                    error "Server error after $max_retries retries"
                    return 1
                fi
                ;;
            *)
                save_message "$conv_id" "system" "Error: Unexpected response (HTTP $http_code)"
                error "Unexpected response (HTTP $http_code): $body"
                return 1
                ;;
    esac
}
parse_incoming_line() {
    #TODO: if line starts with "data: " start recording until blank line. then handle message
    line="$1"
    # echo line: $line

    # Skip empty lines
    [[ -z "$line" ]] && return 0 # Will continue to next line
    [[ "$line" == ": OPENROUTER PROCESSING" ]] && return 0 # Will continue to next line

    # The transaction should stop with CODE:
    if [[ "$line" == "CODE: "* ]]; then
        code=$(echo "$line" | sed 's/^CODE: //')
        if [ "$SPINNER_ON" -eq 1 ]; then
            spinner
        fi
        exit $code
    fi

    if [[ "$line" == "[DONE]" ]]; then
        if [[ -n $buffer ]]; then
            error "ERROR, Buffer is $buffer"
            return 1
        fi 
        return 0 # Will continue to next line
    fi

    # If line starts with "data: ", make sure buffer is empty, add to buffer whats after "data: "
    if [[ "$line" == "data: "* ]]; then
        if [[ -n $buffer ]]; then
            error "ERROR, Buffer is $buffer"
            buffer=""
        fi
    fi

    # Append new data to buffer
    buffer+=${line:6}
    # buffer+="$(printf "%s" "$line")"
    
    # Check if we have a full JSON object (ends with } or [DONE])
    if [[ "$line" == *"}" ]]; then
        if echo "$buffer" | jq empty 2>/dev/null; then
            # debug "Full JSON object: $buffer"
            tool_calls=$(echo "$buffer" | jq -r '.choices[0].delta.tool_calls // empty')
            if [[ -n $tool_calls ]]; then
                [[ -n $conv_id ]] && save_message "$conv_id" "tool" "$tool_calls"
                echo tool_calls "${tool_calls}"
                for tool_call in $tool_calls; do
                    echo "" >&3
                    # local tool=$(echo "$tool_call" | jq -r '.function.name')
                    # # local id=$(echo "$tool_call" | jq -r '.id')
                    # local command=$(echo "$tool_call" | jq -r '.function.arguments.command')
                    # local reason=$(echo "$tool_call" | jq -r '.function.arguments.tool_reason')
                    # # info "Tool: $tool, Running command: $command with reason: $reason ID $id..."
                    # echo "command '$command' reason '$reason' ID '$id'" >&3
                done
                buffer=""
                return 0
            fi
            content=$(echo "$buffer" | jq -r '.choices[0].delta.content // empty')
            if [ "$SPINNER_ON" -eq 1 ]; then
                spinner
            fi
            if [[ ! $content == "" ]]; then
                code=$(echo "$content" | sed -n 's/.*<cmd>\(.*\)<\/cmd>.*$/\1/p')
                rest=$(echo "$content" | sed 's/<cmd>.*<\/cmd>//')
                if [[ -n $rest ]]; then
                    in_box "$rest"
                fi
                if [[ -n $code ]]; then
                    push_to_stdin "$code"
                fi
                full_response+="$content"
            else
                # Finished the response, close the box
                echo "finished" >&3
                [[ -n $conv_id ]] && save_message "$conv_id" "assistant" "$full_response"
                in_box
            fi
        else
            save_message "$conv_id" "system" "Error: Invalid JSON response"
            error "Invalid JSON received: $buffer"
        fi
        buffer=""
    fi
    
}

send_json_to_api() {
    trap "echo '[DONE]' >&3; exec 3>&-" EXIT
    model_endpoint=$1 #(get_config models.openrouter.model_endpoint)
    OPENROUTER_API_KEY=$2 #(get_config models.openrouter.api_key)
    content="$3"
    conv_id=$4
    conversation_mode=$5

    full_response=""
    max_retries=$(get_config max_retries)
    code="ERROR"
    # Validate JSON content
    if ! jq -e . >/dev/null 2>&1 <<<"$content"; then
        error "Invalid JSON content: $content"
        return 1
    fi
    
    local retry_count=0
    local http_code=1
    retry_cond=false
    continue_cond=false
    # if [[ "$conversation_mode" == "stream" ]] || [[ "$continue_cond" == "true" ]] || [[ "$retry_cond" == "true" && $retry_count -lt $max_retries ]]; then
    # fi

    while [ $retry_count -lt $max_retries ]; do
        spinner
        (while IFS= read -r line; do
            parse_incoming_line "$line"
        done < <( \
        curl -sS --no-buffer -X POST "$model_endpoint" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENROUTER_API_KEY" \
        -w "\nCODE: %{http_code}\n" -d "$content") )
        http_code="$?"
        
        # echo "CODE: $http_code"
        break
        # handle_http_code $http_code
        # return_or_retry="$?"
        # [[ ! $return_or_retry -eq 2 ]] && return $return_or_retry
        # 
    done
}

send_message() {
    local prompt="$1"
    local piped_input="$2"
    local conv_id="$3"
    local message_to_send="$prompt"

    # if [[ -n $HISTORY_COMMANDS ]]; then
    #     message_to_send+="\nCommand history (last $COMMAND_HISTORY_LENGTH lines): $HISTORY_COMMANDS"
    # fi

    # term_buffer=$(printf '%q' "$term_buffer")
    # term_buffer=$(echo "$term_buffer" | sed 's/"/\"/g')

    if [[ -n $piped_input ]]; then
        message_to_send+="\nReference: $piped_input"
    fi

    
    # Create new conversation if no ID provided
    if [ -z "$conv_id" ]; then
        # Get model and system prompt from config
        selected_model=$(get_config providers.$(get_config providers.active))
        model=$(echo "$selected_model" | jq '.model')
        api_key=$(get_config_from_json_string api_key "$selected_model")
        model_endpoint=$(get_config_from_json_string model_endpoint "$selected_model")

        local system_prompt=$(get_config system_prompt)
        encrypted=$(get_config encrypted)
        if [ "$encrypted" == "true" ]; then
            system_prompt=$(decrypt_decode "$system_prompt")
        fi

        dynamic_prompt=$(get_config dynamic_prompt)
        dynamic_prompt=$(eval "echo \"$dynamic_prompt\"")
        system_prompt+=" $dynamic_prompt"

        if [[ "$term_buffer" != "" ]]; then
            system_prompt+="\nTerminal Buffer (last $CAPTURE_HISTORY_LENGTH lines): $term_buffer"
        fi

        system_prompt=$(echo "$system_prompt" | jq -Rs '.' | sed 's/^"//;s/"$//')
        # message_to_send=$(echo "$message_to_send" | jq -Rs '.' | sed 's/^"//;s/"$//')
        conv_id=$(create_new_conversation "$model" "$system_prompt")

        debug "Getting prompt template for $model"
        template=$(get_config prompt_template)
        debug "inserting model to template"
        content=$(jq --argjson model "$model" '. + {model: $model}' <<< "$template")
        debug "inserting system prompt and text to template"
        content=$(printf "$content" "$system_prompt" "$message_to_send")
        debug "SELECTED MODEL: $selected_model"
    fi
    # Save user message
    save_message "$conv_id" "user" "$message_to_send"

    # create a temporary named pipe
    PIPE=$(mktemp -u)
    mkfifo $PIPE
    # attach it to file descriptor 3
    exec 3<>$PIPE
    # unlink the named pipe
    rm $PIPE

    send_json_to_api "$model_endpoint" "$api_key" "$content" "$conv_id" &
    
    while read line <&3; do
        if [[ $line == '[DONE]' ]]; then
            break
        elif [[ $line == 'finished' ]]; then
            in_box
        # elif [[ $line == '```bash'* ]]; then
        #     push_to_stdin "${line#* }"
        # else
        #     # in_box
        #     echo "${line#* }"
        else
            debug "Received: $line"
        fi
    done

    # Return conversation ID for future reference
    # debug "Conversation: $conv_id"
}

installation_required() {
    if [ "$SCRIPT_PATH" == "$INSTALL_DIR/$EXEC_NAME" ]; then
        return 1
    # Check if already installed
    elif [ -f "$INSTALL_DIR/$EXEC_NAME" ]; then
        return 1
    fi
    return 0
}
install_xtool() {
        debug "Installing xtool..."
        PAYLOAD_START=$(awk '/^__BINARY__/{print NR+1; exit 0;}' "$0")
        tail -n +$PAYLOAD_START "$0" > "$INSTALL_DIR/xtool"
        chmod +x "$INSTALL_DIR/xtool"
}

do_install() {
    debug "Installing..."

    # Prompt user for required information
    INSTALL_DIR=$(prompt_user "Enter installation directory" "$INSTALL_DIR") 
    INSTALL_DIR="${INSTALL_DIR/#\~/$HOME}"  # Expand ~ manually   
    INSTALL_DIR=$(realpath -m "$INSTALL_DIR")
    EXEC_NAME=$(prompt_user "How will you call your agent?" "$EXEC_NAME")
    EXEC_NAME=$(basename "$EXEC_NAME")
    CONFIG_DIR=$(prompt_user "Enter configuration directory" "$CONFIG_DIR")
    CONFIG_DIR="${CONFIG_DIR/#\~/$HOME}"  # Expand ~ manually
    CONFIG_DIR=$(realpath -m  "$CONFIG_DIR")
    echo config dir: $CONFIG_DIR
    mkdir -p "$INSTALL_DIR" && cp "$0" "$INSTALL_DIR/$EXEC_NAME"
    # if failed, prompt:
    if [ $? -ne 0 ]; then
        debug "Failed to install in $INSTALL_DIR/$EXEC_NAME."  
        return 1
    fi

    # Set the vars in the script
    sed -i "s|EXEC_NAME=\"[^\"]*\"|EXEC_NAME=\"$EXEC_NAME\"|" "$INSTALL_DIR/$EXEC_NAME"
    sed -i "s|INSTALL_DIR=\"[^\"]*\"|INSTALL_DIR=\"$INSTALL_DIR\"|" "$INSTALL_DIR/$EXEC_NAME"
    sed -i "s|CONFIG_DIR=\"[^\"]*\"|CONFIG_DIR=\"$CONFIG_DIR\"|" "$INSTALL_DIR/$EXEC_NAME"
    
    # Make executable
    chmod +x "$INSTALL_DIR/$EXEC_NAME"

    # if install path is not in PATH, add it
    if ! echo "$PATH" | grep -q "$INSTALL_DIR"; then
        export PATH=\"$INSTALL_DIR:\$PATH\"

        # Get the proper rc file for the current using shell:
        if [ -n "$ZSH_VERSION" ]; then
            RC_FILE="$HOME/.zshrc"
        elif [ -n "$BASH_VERSION" ]; then
            RC_FILE="$HOME/.bashrc"
        else
            debug "Unsupported shell"
            return 1
        fi
        debug "Adding $INSTALL_DIR to PATH in $RC_FILE"
        echo "export PATH=\"$INSTALL_DIR:\$PATH\"; $EXEC_NAME --start" >> $RC_FILE
    fi

    # Add xtool if not exists:
    if [ ! -x "$(command -v xdotool)" ]; then
        install_xtool
    fi

    # Remove current script and run the new one
    rm "$0"
    exec "$INSTALL_DIR/$EXEC_NAME" "$@"

    info "Done installing, you might need to restart your shell to use it."
    return 0
}


UPDATE_URL=""

show_version() {
    RELEASE_DATE=$(curl -s "https://api.github.com/repos/$REPO/releases/latest" | jq -r '.published_at')
    printf '\nTerminal assistant script %s\n  Repo: %s\n  Release date: %s\n' "${VERSION}" "${REPO}" "${RELEASE_DATE}"
    exit 0
}

update_required() {
    # What about non-git update option?
    CURRENT_VERSION=${VERSION}
    LATEST_VERSION=$(curl -s "https://api.github.com/repos/$REPO/releases/latest" | jq -r '.tag_name')
    UPDATE_URL="https://github.com/${REPO}/releases/download/${LATEST_VERSION}/install"

    # Check if the API returned a valid version
    if [ "$LATEST_VERSION" == "null" ] || [ -z "$LATEST_VERSION" ]; then
        debug "Failed to fetch the latest version."
        return 2
    fi

    # Compare versions
    if [ "$LATEST_VERSION" != "$CURRENT_VERSION" ]; then
        debug "Newer release available: $LATEST_VERSION (Current: $CURRENT_VERSION)"
        return 0  # Update is required
    else
        debug "You're up to date! ($CURRENT_VERSION)"
        return 1  # No update required
    fi
}

do_update() {
    if [ "$(get_config auto_update)" = "true" ]; then
        runSelfUpdate $0 "$@"
    else
      debug "Not updatding because Auto-update is disabled."
    fi

    return 0
}

runSelfUpdate() {
  debug "Performing self-update..."

  # Download new version
  debug "Downloading latest version..."
  if ! wget --quiet --output-document="$0.tmp" $UPDATE_URL ; then
    debug "Failed: Error while trying to wget new version!"
    debug "File requested: $UPDATE_URL"
    return 1
  fi
  debug "Done."

  # Copy over modes from old version
  OCTAL_MODE=$(stat -c '%a' $0)
  if ! chmod $OCTAL_MODE "$0.tmp" ; then
    debug "Failed: Error while trying to set mode on $0.tmp."
    return 1
  fi

  # Spawn update script
  cat > updateScript.sh << EOF
        #!/bin/bash
        # Overwrite old file with new
        if mv "$0.tmp" "$0"; then
        #   echo "Done. Update complete."
        rm -f \$0
        exec /bin/bash $@
        # else
        #   echo "Failed!"
        fi
EOF

  debug "Inserting update process..."
  exec /bin/bash updateScript.sh $@
}

# # Example usage
# update_required
# if [ $? -eq 0 ]; then
#     echo "Update is needed!"
# else
#     echo "No update required."
# fi

show_usage() {
    cat <<- HELP
$EXEC_NAME - Your assistant, in your terminal.
    USAGE: $EXEC_NAME [OPTIONS] [REQUEST TEXT]

HELP
    exit 0
}

start_terminal_recording() {
    echo "TODO"
    exit 0
}
stop_terminal_recording() {
    echo "TODO"
    exit 0
}

handle_prompt() {
    echo "Handling prompt: $@"
    # exit 0
}

process_arguments() {
    # Parse command-line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in 
            -h*	  ) show_usage;;
            --help	  ) show_usage;;
            --start  ) start_terminal_recording;;
            --stop  ) stop_terminal_recording;;
            --update  ) 
                if update_required; then
                    if [ -n "$2" ]; then
                        UPDATE_URL="$2"
                    fi
                    do_update
                else
                    echo "You are up to date."
                    exit 0
                fi
                ;;
            -v	  ) show_version;;
            -V	  ) show_version;;
            --version ) show_version;;
            -*	  ) error "Unknown command argument $1"; show_usage;;
            *	  ) shift;;
            # --wd)
            #     if [[ -n "$2" && "$2" != --* ]]; then
            #         WORKING_DIR="$2"
            #         shift 2
            #     else
            #         echo "Error: --wd requires a directory argument"
            #         exit 1
            #     fi
            #     ;;
            # *)
            #     echo "Unknown option: $1"
            #     shift
            #     ;;
        esac
    done
}

main() {
    term_buffer=$(get_terminal_buffer) || start_recording

    #     if [ $? -eq 0 ]; then
    # else
    #     debug "Starting terminal recording..."
    #     start_recording
    # fi

    debug "Running from $0"

    if installation_required; then
        debug "Installation is required!"
        do_install "$@"
    else
        debug "Already installed."
    fi

    load_config

    if update_required; then
        debug "Update is needed!"
        do_update "$@"
    fi
    
    init_conversations

    process_arguments "$@"
    if [ -p /dev/stdin ]; then
        # piped_input="$(</dev/stdin)"
        piped_input="$(cat -)"
    fi

    # if user added prompt, handle it
    if [ -n "$1" ]; then
        send_message "$*" "$piped_input"
    elif [ -n "$piped_input" ]; then
        handle_prompt "$piped_input"
    else
        echo "Start Menu/Session"
        update_config "check.me" "{\"hello\": \"world\"}"
        echo "Check is : $(get_config check.me)"
        remove_config "check"
    fi    
}

main "$@"
exit 0

## DO NOT MODIFY BELOW THIS LINE ##
# shellcheck disable=SC1091
__BINARY__
‹ŠÄÀgxtool í}|TÕµïIB "ÌMåˆƒ
1@ƒÍ@'1M‚D'C2!#“™qæŸ·Æ›†´ÜêSëóŞKëÚúÚKmåZjmTğG‹Ôz©¶šë<#ş@ğr©Tç~×Ú{ON†9ıô½ûù¼÷O6ÌYg}÷Úk¯½ö³ÏÎ9gßVS_››“£©§]®7|‰@ªdD$"O@ª´
m2çkçiãÁcLÄW	‚Xæ¦Ï¥tEt’…N°¦¨²(¥³!bÕ
OéòéT§‚ÎÇ4İôÁ+jMÇùUIùZå¸¢Ötä›5">“ÊBxTa¤ä.J·U¦Ë¤¥ÒŸŠ*’úUHfÒ*ÄQ¨â£¦e¦ë–é2iµ”W”ò ĞôÑş“_ƒL·í*¡'“> `MQ•ß×‘üò·éN­Qæ—éÿ4/ıÙ#)µ
—k–_lŸ„âİs»+Î]X^—Ìãx²«?jSW._¡åöhC„©ô9Zó§£+yO²Sñ#·Sú%÷7Ïúé9{n^üĞ‚Ì,ÿlŞUg‘•ƒÒÂè§™½?’aÿˆ¸4„/:: º¸SÃ—]fTäƒà²á4TdÃÿ9fÃÿ‡üC6ø]6ù³‘ÿÄwØØsôëøe†ÓläçÙàÓlòİÅÙüğ¹üL|Ø_o£âš_f¸@6{æÚ”ër|ôè™ÊÁO°±³zff‘ßa#_eƒ×ØØSoƒ¿<³•—†ÓlxŸş†ş5›|¯³±ºüc6øQ›|›läS6ù.°Á»môwÙÈ¯¶Áf£ç!;oµÁï²ÁÛlğmì¹Ú¯µ±3ıS´¯hÛ|@P×CÍ[×|·İõ¯Ä´ùšeÁpÈßì[ôk^ïº®pÈ3|QÃë¢Y[ü¡ö@hÖr¥ß¨ÙàÕ>Ã§µ4úc[ü+¡öğF­åÚˆ?TˆE‚¾MZK]¹…ÜF¸Kkiòu¡HÜ¨·Åc`(t5‡¯öoŠmBô×ãşè¦šnÃŠÂ!ÎC¨t\7üH„ŒØGüQYÔã±N­E¨iµ€£~¿ÅFbµ”:æO×èÄÒf¯_mávÿˆEµ~£­s¹¯	—û»E‰¥Í¬®iS¨m$g™^J4„Tv­åšğ†t&Íş˜Që[ïoô}F`ƒÿš°²²™Z‹Š„diÜ0N•¶®Éô·	cš¿;¢EÃñP{‡ÖÑi!_(úıîimÁpÛzï:¿aP6/Õ<ø¶ÎõŞ_ ¨uPÙüİC‹Ñöx„HĞÒâB8üG²@,Ü6o>RGp<æm²uùkÌ@ƒ‹jÔ³Ñ¶nŸ·#òÑZ2ÒÇ‘íÆhÀğSfm]ÊZÊÊhf²Ï˜1Â,§!Ô×å# Œ»ÒQmâìÊúº¥Ë¼óJæ-ÒÒ§%ÒçóËGN+Ò§#`Ù×¨aŞƒ˜íğ¿<ÌUò™HÄ…ŒÀÔQ¥©Ç³	iM*ÅôT¡˜óËÕŞÇ)Í“h>–ø‡{0§”Xüœ ¦`yÚx9¿Í=ŸÊ8Jÿs–/ĞÎ@<éx’ù	Úy’ŸL¦™U±äïåø|mä…şÜ´~5¯TãÉ~ºp"Ü)çó
ïQxÆøs§ä‡¼"ÍéN§|ÜkÁiş¨Â~^¤@Ğƒü>lÁçYp5Ò¼–æéĞ*Î&€`¨M‡‚VqJ¸¨ÁZp¸*Š,¸u«[p¾O“)Š-8Ïo%^jÁ)o*ZÅaÊ×„TµÒóüÔœœxO+>Qœò±¡U0$?Iœò±¥U0„£a¤Ck«8%\Ş2ĞiÁB„NíN…îVqFz¦(´§U0„[ç1wZğ3…·Zğiü>~–ßfÁÏ¶àZpy‹Ì±Û-ø¹ù'-¸õÆcÈ‚Ó\…½­âŒÊu¾A÷·
†ğâ”[C¸.Nù8Ü*Â/§|4[CøLqÊÇ#­‚!üBqÊÇ­‚!Ü%NÅQöKÂgYğ~‘/´à_µàE¼Ø‚ë|¶/¶à[ğR~‰¯°àrˆáØ*>×"ï±à%¼Á‚_jÁ[,8·*´Zğ2‚vZğù<bÁË-x·_`ÁÇNÇ<0æ1Œy`ÌcóÀ˜Æ<0æ1Œyà¿çcÎó?÷ô~XàÈÿéXé2rSû=½{
v³âÔ‚ §f½„£sFÎˆï¤¸äp
aÖ3Äç¿ŸùÄÓRPrˆùÇ‰Ï#~;ó?"–~’Û˜ÿ>ñ´ä“ÜÊüıÄÓRO²‡ùïO·İÉóß$–v’­Ìÿ=ñ´¤“l`şâi)'YÅ|”øÓ‰/eş&âiI'©3¿–xZÊI2ñ´„“Ô˜o$–n’G¾0ë*âiÉ&9ÌüRâi©&¹ŸùËˆ§%šäóóˆ?“øíÌ_L<-İ%·1?“xZ¢Ineşâii&ÙÃüÄÓ’L2ÂüDâi‰/ÙÊ|.ñ´4“l`şóËÁÓR_²Šù£ÄÓM²”ùˆ§¥™¤ÎüÛÄÓ’L²ù×‰?ŸxùÄÏ şÈTşˆ×‰fşâ/ ~?ó;‰§¥–äóOK,ÉíÌÿˆxZZIncşûÄÓ’Jr+ó÷OK)Éæ¿C<-¡$#Ì“xZ:I¶2ÿ÷ÄÓ’I²ù[ˆ§¥’dóQâi‰$YÊüMÄÓÒHRg~-ñ´$’,dşâi)$©1ßH<-$ü%•r¯p7¯hB)n÷Œ›EvxÕ®¢²¡ŞTó[¿_—ø¬l(qÒ¼²n è*ğ.(‡ƒ=‰OÌ—áÒş¡øu½'Ç9û§Ä“¿‚v’¦^ä¬‚wÌùğµg r:"Íƒ!Orä@³«¨İsÉTÎØÙ¿
ı}µxÕ÷j÷šİÈè÷¨YÊ¨3röß•”Yÿ;8©¸ÕUXv|'õs-$(’€'±Û\¬l_ÙÄ[‰çÌ@'8\{JÏ‡øƒ(|r#Œb%¬¢ì¸yR"Rr+ÙIö²:èAI+¡e2JR6”,§Â.X,ıW ğÊÍlèReÚĞ_ 6ÓĞ‡ı‚rÉæmôáÃ÷ÂŸû– ¦
Tş¼­Ï|)`ÅKˆ4ï ²<†|`Ãóèä°ùlƒq —%DífİÒ{2ÏÙ÷K(„ò )§ZWÊ×“òÍBy˜”_LÊÉ‘\š ò˜rûaDg–æß€qi¤çÏFQ’û„}µÒ˜» cBlÌ¿cŞZc¨)+cdÌŸ!‰’¾HóOÂ˜]°nT­­ƒ'I<úú
Ó_¢‡™ÿé²ã‰·Ìñ€’aÀo1–ƒÎ\ÏÀ÷ğÆd õ5eÀ¯ĞñÍna€˜NPGd”•˜÷clOşõƒs×‹¼ê›B#õq½´`«€|€–Kèï´ĞJ	İÄ³Ÿş"Ï¶ÇÅ¶>~lÕ-¶ÈÖ— g=H3ò9l½Æ#™áñ$>€ÖéB|ñeCæO„ô$½”¤; =ªd“ >oîÆ%,™¯
nºşŒ|P/”yÜƒV
Y P^çƒääC)¤Ö"ç6Œéİ/ n@-ºƒ!gÿ#Èİ¹ã$úa?åv/Óì*D{!õà‚9Ha€8 W ™[`Gr;2îË¼)EíQ\û¤ì*(3H‰XÖ¼€àù€¡÷\€È¸/¦ÈÙ÷<µ‡ÁoKø„ğï%ü[	ß‹Z€ôë~’a#èwzX@k ıVBß‰û's½æ;ûv–É¯W ^ÑÔÒmğßu”ó3H£ÌB¤yß	”ù)…kÊü5îõpUó"QÍıH“œÊŞ€ÿouM2}˜”`¼-0\“Ê†0Î€%æ%ÿ	es¹æh0= ç?*òºy•íÛ‰ÖFµK#á·‘1ŒhA„'ñ¦ÙCI*;8i’’U#ƒğ³æ>¤"L·ÌOMhJ¼îI|œØeÎ¤R=DU;¸`æT!`¨şØĞ{2ß¨€v~ş¡?ñ©>š££¯
…¿B¤ÙMv= KÌå¸2˜‹0^‹6M…{‚™~UbVÏ
ƒP¨,,<½¹ÂÂÒÂ—8³‹%ô†œıb£óŒF5;ÑõÒF÷abÎy ÒÜMÊß`Î¦‹ NíÛÄ`å.ÌŸĞ]oûÈÜNµ38íÅ…X°¤~°5újæiæªQã‰WÌ(;\ëN|tÕÀ’OÌ^h­CÕ#êyªË»uàs<,ÿ:„Ó¶«ÊMd5Yyoõ>›cF’t¥]tMŠş‹™üVœ$Ó1nÁ0ª¨g!ƒÑ|¹,ù&—kr!¬Ù	§¤ióbª§X¢òcüID4Ø)ˆB¶ç!†|‹sÈ„Ê c>L%ß‡Hšß—}T—xåFOâmOï»GškÊ†Êö!Q¢SÓŞÀ_e>ë(qÎèCÆĞ>X¹‰2ÌYtÂ˜†[ƒ‚ş´Ô°sFÉí–òu,¿`)‘Ù_zG<»>¾Â³ëD'ç9Ï+_S¡À/¤†;œ3ªGÒ“}=•ç!­Ÿ¿ÂÓ[¹’(ã{Æd”åş4”šV
Èlƒ±Ïå gÍî{wwŒœÓı	éK®ƒ¬²¯÷Ã
ÌÔ–È™Ú­®â²”y%jÄ“È‚2n5r–Ï{Úz†éÍ£ ~°Ú5	ÍfÉ.&È®á	¼;L¨B»ÈßˆHóó£bü6ãùy4ÓÄ°Át´¸FÒ0PÙò|µË)šrpñÜñ¹j×¬VóûÇ¸ú.º]™ˆ–†iæ%bšŸƒ™^ÅntşØ9zTnÂí†™‹*ÿ5ÆFÍ,€&³‰L~Šd/°ÈCIÌ×)dÿë-.Ü
Kˆ$Évè Ò½a•sÇk‰/Ñf*g¶KoÇ9İ(&ŸdYÙ~¤<Òü'§XE)ÎB.H}­J±)D; ™t]â"çQäà´AÚë&q…Õ'ê]Eu‰O©J
Åmê‚\–«vMm ñqzƒù;2ªwNN£)²tZ>Mw›5l"Ú]*³wkeo@])²ı%†F41£ö$šÑ@˜ ^S¶ÏÍ“n#ñåİú Tı œ³n9Nçóâ†›ÚÍ‡?ekJÑÇÏ ±@÷ô§ÜdÏ0ß8rJÅK=‰ƒ«v›ÿ8º::¶®(; ‹„ûMºéğÀÒé²)¯vUx'aËŸñ÷VsğğG8çıHáI<kşoÂÑ‹Qœ²}Z+_€ˆûI3âßä¨Æ‘£‹ÏK1È4˜Ãd*LC!ª¨ÅTˆ…æ¨lÌBÿ$’éÿÈ˜A~GOS~_ƒ„˜B™«Ö`¤€ß‘ñ×‘1å„¢¾iƒ]Ğ[„ñãn®Í>Ršxöğ“ªß"ƒR3$³B’gÍï}ÂYÅÿçáÌ8"X¯{ÚÌ'øK4fC‘»CùŠ&Tïír·Xğ
b‘ıKÃÚâº½‚.ã¨¯£Ã·»
Í/(ÃÁÊUdÒO‘
5f{x²+ñ‰§wwéB¹¯v‹-§‚£f—4éşÈ¶‰geTùAsôöŞê
æÆŸ`âƒzh(?ˆAüàÇ¸ğ<"ûÊ]`î âècG|êğÜ¾‡Ê$ïöÌlH†•–Œ»SOâ‹&ónv®ˆ·s)Ûó5©ŸìÇEênÎ¡òW—R3xÎ|˜ªq ò'`1…¡QRTÓ!vpó¨3Å¤| ²‡¥qÏò¦¹@È…Hî‡i¹kqV·èÃø7ÉbÙ0>8Wæçiªo2ç áQgáäWi2€Áä¨³e×Qç{;œŸuŞ°+s|w_çNÇMxâw³;ñ**ÿ(nõømtÁ{``Ù!Ñ]%ñ"!¥<† ºË¹«VğqIµ‚*jKÌ-T4#}o8ûÎƒV»¦ã^¯é{×ÙO¿Ã°7ğ{·¦ìİcnçÅoÒá½cÎ)«]“plwX*Ã9ƒÄ‡HdÏ1çùwaÙ‰J}Ô¹:ÿ0.ÙG×3u÷îÉAa‡à˜³cÎüˆ}<%!ÿü8.ÜOãÊµì–¿UÜ¸ë˜³RpÌyı^üĞ 9çìÃoN2çuólQ_û±Êa‡ÿúÎ3©}#wï_üÎş•P
¯m§øÃœï¨¾\‡T‰Fç¾q·{öŸÜ³?N~&û­H»ªŸV'>`ëÌ"‡ÃÛÍPÔ±Õ½5&ÖLnÿ°şCµŒ“#XŸ«@Ù.‹t5CglÇ@9¸ÚÕ ¤Ï`ĞUZCB@ÇIJkxW€Ÿ.y4)êx‡Ä…íÃ4BPcøîÍrÕ?ôø}àiúŞ‡Ü'.Œ¿>ÿÀEÕ®Hü7ø”¸˜õü=Üè5'÷Èqn¾ó{ˆôI‘I¢šâ`Íı8ïºíKØŠº	ºŠĞ
ˆ^Uòóş!gÍ3}˜¥oGé9~ºÓ
WÀ•›0GeâVB³Vs^ú>Ú ç?BùBèynE8®q8®vMÅC‰h-¸|r»˜î,~*˜]ıÚ1gËAˆå§°R…èg¸#áê·œÅÃqˆ#Z!r7·îqÎæY×£²œ—ÎzqÎb:>A–¹b…Îæ¹K8rîBªË¬ø óĞjçœÌ˜ÅàáB7åÊöQÄ‘êÄ—Õ‰£æ?'9¢fê;³°™‹d 0èH(éêıªW=‡œ9võœA·F¢úßeUÕèñ—Ğ…;0¤½pÿbOÚ5ÅÊÛúÎ×œß~7è;{pZvœÆc´¦*jEÙÏĞTÀc^+’BHÍÉ+ÑQlL©gÎC_â»YÂ°7ĞÙ«O°˜®ß¼¦c«(Ò´xŒVÎÇIÉJîM}®Ê| ò¢‹É5eœ;"æ&èÅµÃ˜Liã¨ÑÂüF¨öTŞ“Ò4ãÚ¥Ê&:m\á©ü:-öT6‚:û›Èò•ù÷b~ÈMOºx*ï#©Ë=•ß%z‰§ò^¢¯%]BœV¯Y¼(y‹7³²ñ8—ZNb@JĞ¢¨¥ÁS_¯œõêWæ¹ah.ÅQ.Ë€ü€k/4ñÍ7Í¦Ó7Í)TÎ%®ã‡ò§CwÔãoA H
l3¹;¾„îèœ¸csiï‰ÉÆÙ½'F©¹j?ªêËíÜ¯ Wšó÷ræë îxE}â}Lşijç¬ş=®Âïsã{¬Ëˆÿ:’ì$ÁHö L†ÙÁ	ò¾H:˜_Œå+hØ…BC ’Q¾©ÂVù)Ä“íˆKÿ­¥WıuNcóÀ˜Æ<0æÿ ·m4mïR®À[W¼üRıåá3òÏŸ»b™/
:^éíâ=µ‰ô¢^yûÌ»¼¦Ùë^Ö\w]weİòêkWj­¼Æ»Ü}M¶¢¹¶ÂÛÔÜX·üJmEh}(¼1¤‰Óô Ş°»L1uÕ—é¥İ³‚İsôæ€ô_¦ÏŠMÔºÂñ˜¿ï…œy£ò•0ë
^‰xED[0Ğ¶^DãÅ»8ÃëZëı›èÇ(ºĞ¼tÕ®ƒÓCxŸMXalŠøµ •;Öæix/ÓğfŸà51¼¥†wñº/›Õ®oÂa¢¶‘ßòëàWøÄ¹¯o²ùğæ–`éU@yÊ%„2–ğ‹h½1Q[Ö¬\ï ÷Õ&j1¿/ÚÖ‰7¹b†Ô§ü«·…»º|¡va¼hT-:×›·óÄkƒ:U­o^c£WKpÁáj<õÇb~JŸ£/ëôE‘¿?*´Q<¼ë÷Ù	H=+b¾uşË&êz·õUÒ¤5ú*_t]¬¤¤dÍÄ‰Ë„™1K{WÏêé]Ì‚pº²ÉêËÂ!#Š<N¿ÎµÇz(Şñµ#uºMéİú¦S4ĞKˆ–¤¼¿6â¥J¸5Å[¨Á˜UhdÊş65:·ÏQÊTÓµêËP–q#¦·Å£Q¼bªGÂ± µÂ¬ú¬VşêK[ÉıHÇ¦xÇÒ®õG-şk
tÅñ²¦_÷I·ñâ²Ê ¿Ã˜£Ï«ì
´·ısôù•ÑÀºNc¶2”:`Vµi•Ü$ñlZ·0B)ˆG²&×õ´Ñf³j ¾Ÿ—ú»¥8ò4­ÁÇƒ¢£s©^ ˜K]I6"¬ÎÄb·ÈUö8$£¡HÇ›ŸT’SC3Åúd<¤3Ç§Ñ)èuSnëª‰î¢F3(#bòÜ‹ÑQ~?Y‡(Ëˆ¿-Ğh“Ré¤jÌËLí–cá_IJã£%ÙF½Sä‹·£Ùhw@ƒ°2gua‘µé^ÎÍ^IëÔ³GÌ¶”9cV…•tÄiuÕ:r§QFº/¸iôHƒÄ mWaM<„c@¦»1Vùtƒ®qB^¦Ê¦|D½C­eĞÏ0X-u_0¨oÄÜ¥/b'Ötûº"A?¸b`ËJKuü ]ÄˆŞ[–æÑTõF¿Òø"D¸1ÎôøƒÁğ}e8l¿€şfKaDoÔs<€+
êº|]ïÂx…Ë»E.}YGÇú+	„UiŸì÷4ºÓh¤t«Ë™°ƒ{çß–†íFÇüÛ¤ñ.`Ì*J>âaä;ØU¥²Ÿ"7ZŸhÄ:ZZ¦ ˆá.Öš–ƒo7:ç°Ã;ı4Ö¦°×5MÈrOÉ–³°,•…ú’:F6iıiÏ[¿SssK
Ã’ŠU6M+¯Øƒ_:`Ùä¶4ƒ“œsó? Š%)­ç÷©Ô~Ğ­S©Ö<¼Óûïx,|ÕÛ©Ô	ĞÈ;©ÔT¬‹ö€ÒRóvĞ*ĞaĞĞ†wS©>Pí½Tê)PıP*EÓ_k3K@KA@÷ƒÒ÷*
±äs7èV”>İõ]ùa-¹”/\ƒæÜÒ¨åtæœ;iBÁVè&œ¦{†S©‹@µê	¼¢íÂi9~¾šJ’Ga­£è*çéz´+ÎY|ñ|×L -f¯ÆÊè"›«U¹/Mt¸Oç÷Ô»5£Ü“@)P~[ğk †õ'’/ô:
l'ğ‹%îN2Oá×|½ÀK×;*®qTÕ:<µ†:Gi³ÈMØkBfd$Y·£°7¢ß`ÑZGK­£µÖÑ¹Ô©sTİ4ÑQXÍvVAT‡íKàÿs©H·9÷*GQo^µ£5·ÊÑy#Rëè®uôäÔ:îÌ©vlÍ©s´nšè(‚õnGAíéøÒ‘¶u§‘¥ÂÁÜGÑèĞ7s;Š{óëûsr_è(v;t·£"KÉ rø6¤ù#Òâ1TnZ;?ìá-¹H´™ôõËİê(‚™H/|:Ùz´üí’}ºÍ8=Ü şPÒñ­ÜGÑ`^Cß2îjGñæ|·£´w|µ#²n¤|µ(_“#’7%g¢£†ÃÚ¥#ÖŠïPû{	íò=jĞûí\ˆ|+o©C·ÔQ¼…ônïvTôN¸Ò1œËõHßÚ¹kê“¤-ƒ”fK‡üã!ÿ\éè·›í8	bQ[µòï`Åè[ÛQfÊS¦‡yÒ¿Õ†Ü-§¸ÂcaÌcóÀ˜Æ<0æ1Œy`ÌcóÀ˜Æ<0æ¿Åêû€ê{€tOáqºaGPüÓü‹ük<}Ñš¾yHAİ÷k:³éoØñr¼/ÆA}Çğ\ÉÓÒ …sIÏÖ¸(¨øÿø2&~H®©u—ÂÓ•ß¨¥çÏ)¨åÂJÉŸ.`^ÿ¢Ói’WDŠi¦W ²XZ?:²‡§²8Ğë4Š‚*¼¯XRPvlúÛ€E’Ç‹^\%ŠçôDù¤#±^É¼²ÏQ3¿\Æãå#æ•İRíÿs¢¾#Ÿ™ñB] µ’^'i‡¤$İ,é=’>"éIŸ“ô5IIz\ÒñhÎ’ô"IJZ+éu’vHºAÒÍ’Ş#é#’îô9I_“ô¤Ç%?Sæ/éE’.”´VÒë$ítƒ¤›%½GÒG$İ!és’¾&é!IK:şB™¿¤I*P¬ßùÄÙ•Ë–]¦ãkï³õ²ò’y%eú¼Òyå¥¥økö¨Ee¥JIšlœöi*KTV\ô‡)šú.¿JGã@vvºß)œÖEsĞK3Û—«i:zq,—’Ç«¯£¾_©ğ•6ø:ÆÚ~^€Õ4^³“ø*<¡?ú[Af`|È†o†`6ü;Œ;´á9B¯Áãô»6ò.”÷|ùSí›Ákş}ÌFş—6øolpz92›Çëøe†|ø#›üY6øWmğrÂsšº>¨|.³‘¿†q‡ÖJä@àulĞ•Àé{ÛÛ}£í‰à³ÑµÁûmğ»whC²¨ëÎı6ò? ®K¬d7ğ)´R^%Peç=Ã6ø§6ø8îÖÅùùÀ³ô—K¸]*¿ˆq‡Ö€÷C(ğßv@ÅwñÓÂ>ÿM ”^[˜ÉÈèÃÍROÔÃ‚ıM![ûù.pªÇ'}Bº~ş“üI>·HÛ*åUîOØÈï•ú‡2ôï·‘GêWã§Ò„åÑå¼FÍ{şb£g.ĞÙÊ{>›q‡¶}È‘ÿ„S·¼Ç_¼Ğòzeÿ:ù.ÆZ¡¬/U®¸üVüAüqüeüücàT®½õ~ÌF>eƒOæqÛ¡E¤Ÿe÷Ö¦ÙŒçÙà‹gûŞÿrypê™í–¾\”­ÜjƒßÇ¸C;"ëëAYÁ?²‘^ÊëR¾XÊÿÑFşS)¿íR!ÈgÅi.ÀlvN¶ÁÏbÜ¡•^(ôğßqz.á¹heºÀÓGúp}I>N¹Š·Æã­mÄÓ^Ou£æ½²şÚ¥îzïµµµMx6´Ù½´¾›%T_çAë–|½¿1Û§ı3ö6 Ç&è»ùx†ŸtôŠç°¿Ø¦€éY)¶SÀc2†·{DıÕéÍšFïŸ ¾÷_eıÆ=¶áşì:¸ÏØ ‚MGÏÃ·òi/€Q@‹uçú¤ ÛÎéçµî€7¡½x;‚Ñª²ì»0z3ƒv8Û<X·•ø«»YÔ]×âF/±mÏØª‚¶6•=*[Œ‚XyÖı/¼Şvìw!¶8ÈØK"&ŸôÒ£oü4åÉÚÑ;ŒÊOeyùá¯zÌq¤ª­»>DÃaÃº…×‹-<¼5Ë«±a‡Ø—a”Zù\³†âáÿ¨("övâ9lıÁ[3ÀQxªudÑ°2·õ½{Gº¼Âxzâ†~R»q Sl‘‘ïÚXLù7ÎÀ61?Úvæédåd?6ƒHÔ36öÈØ†"-:¿bd×‹4(Ò§wõğb;“Ñ[”p?U;wÄØ% 	ô9ìPÂû‚p#Ù…Ä²5‰ØíbTVbG‹Q×OMHí‰1:jÔ†ñ`:E¡f"—–Cœ–±İÆˆ8Ü¦Z£¨~ºl¤]Y7!Åbğñò³y£¶7QÛ½ğn^‰4­0|kA±íÓNuÆûD´<‚í/YŠ—DÔ-#ĞÚx ›Á©r/­›køÖi,ŞéÃ>.%í›B´Sl3Â1üQŞÆÊxG“ <‹­„Í,1ğD¸VÂ#SI4Ì>/ñwz;°WˆßÛÙ´Š)¼¾h£§PçPìë
´Áô=:”pB³VBS«ÿoq:²×DæUëQY?S<]Ş&à‡i ‡
™^Ñ*‰+¢æ·Š_ˆkún™^Q—”—çQ¡œ5ı2½¢ú(ië3t"‚î“ñí˜°²_­³)ªò/õdÚOÓ1ZcSéÕ:œ¢Å¸ŞS sğSéÕzX ™¬Ò«u=EÕ:D8k¸­™©ôjLÑVö+9E¿xZƒSüœ +ºU¦W>VöKXÄ	Õ‰J¯ÖUë€*•^•ÿ^™~©T¨Öí‘NéÏÆ/3ı÷€‘O”~MCAç£FíÛ2ÛÏˆ´¦×u!­(?ShQ€;YŠş œ5½šï)ºß°•Na?Æ‰5½ZPT.«*ñô}¾~&Ó+ÿkU2FÒmjAXÂ™ùÓº	å¯Ò«u*EÉ?Öé¿}ˆ´¦¯ºZH+ÊÛ¢@ÕŸ‚~‡~²Û²¿g¦¼â}i–ôj_ E•D8(^ÑÃ@©í¨üÕº›¢¥Ò1Ôş)¨tÊŸ£ò«ôjŸ!E‹)‘%¨ôŠşqÖôj^Ñû(ÒT:EsoM¯ÖUv**]šGbÂ”ıÛ|"Fİ§+AIõ¾Gù—fà*=ïÖ@²¬Tµ=#ê>7"¦ëÕ“²_ôge»H)7	zUœÊWñSp’-ıõüWM£õ=kÈ`µÿ@$T@ğw  
